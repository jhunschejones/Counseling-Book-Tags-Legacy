# Counseling Book Tags

## Overview
Counseling Book Tags is a web application that allows users to access information from a public book API, coupled with custom user-defined tags and comments that describe the different counseling topics displayed in each tagged book. The application is built using Node.js and Express, along with a MongoDB database and Firebase user authentication.

## Building Process

### Back End

This application was built using an API-first approach and an MVC architecture patter *(where possible)*. This meant first planning out the structure of the API before building the rest of the application around this initial structure. Another key element of this type of design is clear API documentation. I intentionally constructed a JSON response at the `/api/v1` that describes for a user *(or developer)* exactly what endpoints are available, their uses, and some expected response structures. Designing an API before the UI is also helpful because it enabled me to be intentional about the data I was returning, making sure it was no more or less than will be needed. This helps make consumption of these API endpoints to easier both later on in the development process, and as the application grows in the future. Finally, through the process of modifying data being returned by external API's, I was able to create  a layer of separation between my application and the data structure of any 3rd party API's it consumes. If an external API that the site relies on makes a change to its data structure, I will only need to make updates in one spot of the application's API layer, rather than throughout the front and back end.

### Front End 

Early in the development process I pinned down the exact requirements for the user experience with the project stakeholders. This helped when I got to the UI layer because I was able to implement all the requested features as efficiently as possible without piling in extra code. As a good example, the home page pulls all the tags from the database and displays them as pill-badges. After this initial database call, no further database calls are required as long as the user is navigating around the home page. *(This improves performance on the front end and lightens the load on the database.)* The page then allows the user to select by alphabet letter, or "all tags", then filter the tags on the page with an input field. The page uses session storage to remember which selection the user made, and a column layout so that it can break down usably on a mobile screen. Finally, each tag sends the user to the search page with the tag text as the value. Long tag text is cut down at a full word break and an ellipse is added to keep the page clean. I was also careful to construct all buttons with event listeners instead of `onclick` functions so that the page will fully function in Firefox.

### User Focus

My favorite point in any project is when I get to start user testing and see how people expect the application to function. Often there are a few small improvements that are easy to identify and make so that the interface can be as intuitive as possible. I firmly believe that the burden of providing an easy user experience falls fully on the developer. A user should not have to put forth an inordinate amount of effort to learn how a tool or page functions. This methodology played out in Counseling Tags in a few places. First, as a part of the streamlining process for slower internet connections, I had worked to limit the number of sequential API calls that needed to be made to populate any one page. In its first iteration, this meant that when a user had signed in and chose to navigate to the `Details` page, the book was added to the database. While doing user testing, however, I noticed that users were actually navigating to this page to see the book cover and details to determine if it was the book they were intending to tag. This caused the issue of books being added to the database unnecessarily *(with no tags or comments*.) I implemented a three-part solution to resolve this issue on as many layers as possible.

1. I changed the `Search` page to show book covers when a user hovered over a result. This cut down on the amount of extra trips to the `Details` page a user would make while looking for a specific book.
2. I moved the AJAX call to add a book to the database so that it was called when a user chose the option to add a tag or a comment. *(More on this later.)*
3. I built a simple utility tool that provided a GUI for site admins to quickly identify books in the database that do not have any tags or comments, then remove these books in only two clicks.

As I rolled out my next iteration of the application to users I found these improvements greatly reduced both the amount of time it took a user to find the book they were looking for and the number of books being added to the database with no comments or tags. In an effort to provide as seamless a process as possible, the first iteration of the `Update` page shared many UI elements with the `Details` page, except it allowed users to modify their tags and comments. This was a great idea in theory, because I could limit user authentication API calls to the `Update` page and thereby decrease page-load times for the `Details` page, all without really revealing to the user that they were changing pages when they decided to update a book. In practice however, users would click the button to add a book and the page would change to the update page so seamlessly that they thought it wasn't working. They then had to click the button again to toggle open the modal to add a tag or a comment. Following my philosophy of preferring functionality that reflects user expectations, I added an additional URI parameter to tell the `Update` page which button the user had clicked to get there. The `Update` page could then read in this parameter and toggle open the respective Modal without the user needing to click on the *add* button a second time. This almost entirely solved the problem, except if a user on the `Update` page were to refresh the page with this URI parameter in play, it would toggle open the modal again. In practice, this did not reflect what the users had hoped to see by refreshing the page, so I added functionality to remove this new URI parameter once a modal was toggled so that when the `Update` page was refreshed, it would not re-open a modal.

## Outcome

The most recent iteration of the site has been deployed and can be viewed at http://www.counselingbooktags.com/. It is now being demonstrated to project stakeholders so that they can add the first round of production data, after which point it will become available to all end users. I believe the additional time spent in planning both the API structure and the application functionality were the main reasons this application was able to reach its final stages in almost half the time it was originally allotted. Sticking to a user-focused design philosophy meant more iterations spent on small UI tweaks, but I also believe this contributed to the familiar feel of the site and will help it be useful to a wider-ranging audience.

Please let me know if you have any feedback or questions, I am always happy to connect with other developers and hear feedback on my projects! I can be reached at joshua@hunschejones.com.
